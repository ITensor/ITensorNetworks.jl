var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#ITensorNetworks.AbstractNetworkIterator","page":"Reference","title":"ITensorNetworks.AbstractNetworkIterator","text":"abstract type AbstractNetworkIterator\n\nA stateful iterator with two states: increment! and compute!. Each iteration begins with a call to increment! before executing compute!, however the initial call to iterate skips the increment! call as it is assumed the iterator is initalized such that this call is implict. Termination of the iterator is controlled by the function done.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ITensorNetworks.EachRegion","page":"Reference","title":"ITensorNetworks.EachRegion","text":"struct EachRegion{SweepIterator} <: AbstractNetworkIterator\n\nAdapter that flattens each region iterator in the parent sweep iterator into a single iterator.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ITensorNetworks.ITensorNetwork","page":"Reference","title":"ITensorNetworks.ITensorNetwork","text":"ITensorNetwork\n\n\n\n\n\n","category":"type"},{"location":"reference/#ITensorNetworks.IncrementOnly","page":"Reference","title":"ITensorNetworks.IncrementOnly","text":"struct PauseAfterIncrement{S<:AbstractNetworkIterator}\n\nIterator wrapper whos compute! function simply returns itself, doing nothing in the process. This allows one to manually call a custom compute! or insert their own code it in the loop body in place of compute!.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ITensorNetworks.ProjTTN","page":"Reference","title":"ITensorNetworks.ProjTTN","text":"ProjTTN\n\n\n\n\n\n","category":"type"},{"location":"reference/#ITensorNetworks.ProjTTNSum","page":"Reference","title":"ITensorNetworks.ProjTTNSum","text":"ProjTTNSum\n\n\n\n\n\n","category":"type"},{"location":"reference/#ITensorNetworks.RegionIterator","page":"Reference","title":"ITensorNetworks.RegionIterator","text":"struct RegionIterator{Problem, RegionPlan} <: AbstractNetworkIterator\n\n\n\n\n\n","category":"type"},{"location":"reference/#ITensorNetworks.TreeTensorNetwork","page":"Reference","title":"ITensorNetworks.TreeTensorNetwork","text":"TreeTensorNetwork{V} <: AbstractTreeTensorNetwork{V}\n\n\n\n\n\n","category":"type"},{"location":"reference/#ITensorNetworks._DensityMartrixAlgGraph","page":"Reference","title":"ITensorNetworks._DensityMartrixAlgGraph","text":"The struct stores data used in the density matrix algorithm. partition: The given tn partition outtree: the binary tree structure of the output ITensorNetwork root: root vertex of the bfstree for truncation innerindstosim: mapping each inner index of the tn represented by partition to a sim index caches: all the cached density matrices\n\n\n\n\n\n","category":"type"},{"location":"reference/#ITensorNetworks._approx_itensornetwork_density_matrix!-Tuple{DataGraphs.DataGraph, NamedGraphs.NamedGraph}","page":"Reference","title":"ITensorNetworks._approx_itensornetwork_density_matrix!","text":"Approximate a partition into an output ITensorNetwork with the binary tree structure defined by out_tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks._approx_itensornetwork_ttn_svd!-Tuple{DataGraphs.DataGraph}","page":"Reference","title":"ITensorNetworks._approx_itensornetwork_ttn_svd!","text":"Approximate a partition into an output ITensorNetwork with the binary tree structure defined by out_tree by first transforming the partition into a ttn, then truncating the ttn using a sequence of SVDs.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks._binary_tree_structure-Tuple{ITensorNetworks.ITensorNetwork, Vector}","page":"Reference","title":"ITensorNetworks._binary_tree_structure","text":"Given a tn and outinds (a subset of noncommoninds of tn), get a DataGraph with binary tree structure of outinds that will be used in the binary tree partition. If maximally_unbalanced=true, the binary tree will have a line/mps structure. The binary tree is recursively constructed from leaves to the root.\n\nExample:\n\nTODO\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks._contract_deltas-Tuple{ITensorNetworks.ITensorNetwork}","page":"Reference","title":"ITensorNetworks._contract_deltas","text":"Given an input tensor network tn, remove redundent delta tensors in tn and change inds accordingly to make the output tn represent the same tensor network but with less delta tensors.\n\n======== Example: julia> is = [Index(2, string(i)) for i in 1:6] julia> a = ITensor(is[1], is[2]) julia> b = ITensor(is[2], is[3]) julia> delta1 = delta(is[3], is[4]) julia> delta2 = delta(is[5], is[6]) julia> tn = ITensorNetwork([a, b, delta1, delta2]) julia> ITensorNetworks.contractdeltas(tn) ITensorNetwork{Int64} with 3 vertices: 3-element Vector{Int64}: 1 2 4\n\nand 1 edge(s): 1 => 2\n\nwith vertex data: 3-element Dictionaries.Dictionary{Int64, Any} 1 │ ((dim=2|id=457|\"1\"), (dim=2|id=296|\"2\")) 2 │ ((dim=2|id=296|\"2\"), (dim=2|id=613|\"4\")) 4 │ ((dim=2|id=626|\"6\"), (dim=2|id=237|\"5\"))\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks._contract_deltas_ignore_leaf_partitions-Tuple{DataGraphs.DataGraph}","page":"Reference","title":"ITensorNetworks._contract_deltas_ignore_leaf_partitions","text":"Given an input partition, contract redundent delta tensors of non-leaf vertices in partition without changing the tensor network value. root is the root of the dfs_tree that defines the leaves. Note: for each vertex v of partition, the number of non-delta tensors in partition[v] will not be changed. Note: only delta tensors of non-leaf vertices will be contracted. Note: this function assumes that all noncommoninds of the partition are in leaf partitions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks._delta_inds_disjointsets-Tuple{Vector{<:ITensors.ITensor}, Vector{<:ITensors.Index}}","page":"Reference","title":"ITensorNetworks._delta_inds_disjointsets","text":"Given a list of delta tensors deltas, return a DisjointSets of all its indices such that each pair of indices adjacent to any delta tensor must be in the same disjoint set. If a disjoint set contains indices in rootinds, then one of such indices in rootinds must be the root of this set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks._densitymatrix_outinds_to_sim-Tuple{Any, Any}","page":"Reference","title":"ITensorNetworks._densitymatrix_outinds_to_sim","text":"Returns a dict that maps the partition's outinds that are adjacent to partition[root] to siminds\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks._distance-Tuple{ITensorNetworks.ITensorNetwork, Vector}","page":"Reference","title":"ITensorNetworks._distance","text":"Sum of shortest path distances among all outinds.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks._introot_union!-Tuple{DataStructures.IntDisjointSets, Any, Any}","page":"Reference","title":"ITensorNetworks._introot_union!","text":"Rewrite of the function DataStructures.root_union!(s::IntDisjointSet{T}, x::T, y::T) where {T<:Integer}.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks._maxweightoutinds_tn-Tuple{ITensorNetworks.ITensorNetwork, Union{Nothing, Vector}}","page":"Reference","title":"ITensorNetworks._maxweightoutinds_tn","text":"create a tn with empty ITensors whose outinds weights are MAXWEIGHT The maxweighttn is constructed so that only commoninds of the tn will be considered in mincut.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks._mincut-Tuple{ITensorNetworks.ITensorNetwork, Vector, Vector}","page":"Reference","title":"ITensorNetworks._mincut","text":"Calculate the mincut between two subsets of the uncontracted inds (sourceinds and terminalinds) of the input tn. Mincut of two inds list is defined as the mincut of two newly added vertices, each one neighboring to one inds subset.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks._mincut_inds-Tuple{Pair{<:ITensorNetworks.ITensorNetwork, <:ITensorNetworks.ITensorNetwork}, Dict{<:ITensors.Index, <:ITensors.Index}, Vector{<:Vector{<:ITensors.Index}}}","page":"Reference","title":"ITensorNetworks._mincut_inds","text":"Find a vector of indices within sourceindslist yielding the mincut of given tnpair. Args: tnpair: a pair of tns (tn1 => tn2), where tn2 is generated via _maxweightoutindstn(tn1) outtomaxweightind: a dict mapping each out ind in tn1 to out ind in tn2 sourceindslist: a list of vector of indices to be considered Note: For each sourceinds in sourceindslist, we consider its mincut within both tns (tn1, tn2) given in tnpair. The mincut in tn1 represents the rank upper bound when splitting sourceinds with other inds in outinds. The mincut in tn2 represents the rank upper bound when the weights of outinds are very large. The first mincut upper_bounds the number of non-zero singular values, while the second empirically reveals the singular value decay. We output the sourceinds where the first mincut value is the minimum, the secound mincut value is also the minimum under the condition that the first mincut is optimal, and the sourceinds have the lowest all-pair shortest path.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks._mincut_partitions-Tuple{ITensorNetworks.ITensorNetwork, Vector, Vector}","page":"Reference","title":"ITensorNetworks._mincut_partitions","text":"Calculate the mincutpartitions between two subsets of the uncontracted inds (sourceinds and terminal_inds) of the input tn.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks._mps_partition_inds_order-Tuple{ITensorNetworks.ITensorNetwork, Union{Nothing, Vector}}","page":"Reference","title":"ITensorNetworks._mps_partition_inds_order","text":"Given a tn and outinds, returns a vector of indices representing MPS inds ordering.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks._optcontract-Tuple{Vector}","page":"Reference","title":"ITensorNetworks._optcontract","text":"Contract of a vector of tensors, network, with a contraction sequence generated via sa_bipartite\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks._partition-Tuple{NDTensors.BackendSelection.Algorithm{:mincut_recursive_bisection}, ITensorNetworks.ITensorNetwork, DataGraphs.DataGraph}","page":"Reference","title":"ITensorNetworks._partition","text":"Given an input tn and a rooted binary tree of indices, return a partition of tn with the same binary tree structure as indsbtree. Note: in the output partition, we add multiple delta tensors to the network so that the output graph is guaranteed to be the same binary tree as indsbtree. Note: in the output partition, we add multiple scalar tensors. These tensors are used to make the output partition connected, even if the input tn is disconnected. Note: in the output partition, tensor vertex names will be changed. For a given input tensor with vertex name v``, its name in the output partition will be(v, 1). Any delta tensor will have name(v, 2), and any scalar tensor used to maintain the connectivity of the partition will have name(v, 3). Note: for a given binary tree with n indices, the output partition will contain 2n-1 vertices, with each leaf vertex corresponding to a sub tn adjacent to one output index. Keeping these leaf vertices in the partition makes laterapproxitensornetworkalgorithms more efficient. Note: name of vertices in the output partition are the same as the name of vertices inindsbtree`.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks._rem_leaf_vertices!-Tuple{ITensorNetworks.ITensorNetwork}","page":"Reference","title":"ITensorNetworks._rem_leaf_vertices!","text":"For a given ITensorNetwork tn and a root vertex, remove leaf vertices in the directed tree with root root without changing the tensor represented by tn. In particular, the tensor of each leaf vertex is contracted with the tensor of its parent vertex to keep the tensor unchanged.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks._root_union!-Tuple{DataStructures.DisjointSets, Any, Any}","page":"Reference","title":"ITensorNetworks._root_union!","text":"Rewrite of the function DataStructures.root_union!(s::DisjointSet{T}, x::T, y::T). The difference is that in the output of _root_union!, x is guaranteed to be the root of y when setting left_root=true, and y will be the root of x when setting left_root=false. In DataStructures.root_union!, the root value cannot be specified. A specified root is useful in functions such as _remove_deltas, where when we union two indices into one disjointset, we want the index that is the outinds if the given tensor network to always be the root in the DisjointSets.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks._sim-Tuple{ITensors.ITensor, Any}","page":"Reference","title":"ITensorNetworks._sim","text":"Replace the inds of partialdmtensor that are in keys of inds_to_siminds to the corresponding value, and replace the inds that are in values of inds_to_siminds to the corresponding key.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks._update!-Tuple{ITensorNetworks._DensityMatrixAlgCaches, NamedGraphs.NamedEdge, Vector, Vector{ITensors.ITensor}, Any}","page":"Reference","title":"ITensorNetworks._update!","text":"Update caches.e_to_dm[e] and caches.es_to_pdm[es]. caches: the caches of the density matrix algorithm. edge: the edge defining the density matrix children: the children vertices of dst(edge) in the dfstree network: the tensor network at vertex dst(edge) indsto_sim: a dict mapping inds to sim inds\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.add-Tuple{ITensorNetworks.AbstractITensorNetwork, ITensorNetworks.AbstractITensorNetwork}","page":"Reference","title":"ITensorNetworks.add","text":"Add two itensornetworks together by growing the bond dimension. The network structures need to be have the same vertex names, same site index on each vertex\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.binary_tree_structure-Tuple{ITensorNetworks.ITensorNetwork, Vector}","page":"Reference","title":"ITensorNetworks.binary_tree_structure","text":"Given a tn and outinds (a subset of noncommoninds of tn), outputs a directed binary tree DataGraph of outinds defining the desired graph structure\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.binary_tree_structure-Tuple{ITensorNetworks.ITensorNetwork}","page":"Reference","title":"ITensorNetworks.binary_tree_structure","text":"Outputs a directed binary tree DataGraph defining the desired graph structure\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.contract_approx","page":"Reference","title":"ITensorNetworks.contract_approx","text":"Approximate a given ITensorNetwork tn into an output ITensorNetwork with output_structure. output_structure outputs a directed binary tree DataGraph defining the desired graph structure.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ITensorNetworks.contract_approx-Tuple{NDTensors.BackendSelection.Algorithm{:density_matrix}, DataGraphs.DataGraph}","page":"Reference","title":"ITensorNetworks.contract_approx","text":"Approximate a binary_tree_partition into an output ITensorNetwork with the same binary tree structure. root is the root vertex of the pre-order depth-first-search traversal used to perform the truncations.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.contract_approx-Tuple{Union{NDTensors.BackendSelection.Algorithm{:density_matrix}, NDTensors.BackendSelection.Algorithm{:ttn_svd}}, ITensorNetworks.ITensorNetwork, DataGraphs.DataGraph}","page":"Reference","title":"ITensorNetworks.contract_approx","text":"Approximate a given ITensorNetwork tn into an output ITensorNetwork with a binary tree structure. The binary tree structure is defined based on inds_btree, which is a directed binary tree DataGraph of indices.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.delta_network-Tuple{Type, ITensorNetworks.IndsNetwork}","page":"Reference","title":"ITensorNetworks.delta_network","text":"RETURN A TENSOR NETWORK WITH COPY TENSORS ON EACH VERTEX. Note that passing a link_space will mean the indices of the resulting network don't match those of the input indsnetwork\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.fidelity-Tuple{Vector{ITensors.ITensor}, Vararg{ITensors.ITensor, 5}}","page":"Reference","title":"ITensorNetworks.fidelity","text":"Calculate the overlap of the gate acting on the previous p and q versus the new p and q in the presence of environments. This is the cost function that optimisepq will minimise\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.findall_on_edges-Tuple{Function, DataGraphs.AbstractDataGraph}","page":"Reference","title":"ITensorNetworks.findall_on_edges","text":"Find all edges e such that f(graph[e]) == true\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.findall_on_vertices-Tuple{Function, DataGraphs.AbstractDataGraph}","page":"Reference","title":"ITensorNetworks.findall_on_vertices","text":"Find all vertices v such that f(graph[v]) == true\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.findfirst_on_edges-Tuple{Function, DataGraphs.AbstractDataGraph}","page":"Reference","title":"ITensorNetworks.findfirst_on_edges","text":"Find the edge e such that f(graph[e]) == true\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.findfirst_on_vertices-Tuple{Function, DataGraphs.AbstractDataGraph}","page":"Reference","title":"ITensorNetworks.findfirst_on_vertices","text":"Find the vertex v such that f(graph[v]) == true\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.gauge_error-Tuple{ITensorNetworks.VidalITensorNetwork}","page":"Reference","title":"ITensorNetworks.gauge_error","text":"Function to measure the 'distance' of a state from the Vidal Gauge\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.is_multi_edge-Tuple{ITensorNetworks.AbstractITensorNetwork, Any}","page":"Reference","title":"ITensorNetworks.is_multi_edge","text":"Check if the edge of an itensornetwork has multiple indices\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.optimise_p_q-Tuple{ITensors.ITensor, ITensors.ITensor, Vector{ITensors.ITensor}, ITensors.ITensor}","page":"Reference","title":"ITensorNetworks.optimise_p_q","text":"Do Full Update Sweeping, Optimising the tensors p and q in the presence of the environments envs, Specifically this functions find the pcur and qcur which optimise envsgatepqdag(prime(pcur))*dag(prime(qcur))\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.path_graph_structure-Tuple{ITensorNetworks.ITensorNetwork, Vector}","page":"Reference","title":"ITensorNetworks.path_graph_structure","text":"Given a tn and outinds (a subset of noncommoninds of tn), outputs a maximimally unbalanced directed binary tree DataGraph of outinds defining the desired graph structure\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.path_graph_structure-Tuple{ITensorNetworks.ITensorNetwork}","page":"Reference","title":"ITensorNetworks.path_graph_structure","text":"Outputs a maximimally unbalanced directed binary tree DataGraph defining the desired graph structure\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.random_tensornetwork-Tuple{Random.AbstractRNG, Distributions.Distribution, ITensorNetworks.IndsNetwork}","page":"Reference","title":"ITensorNetworks.random_tensornetwork","text":"Build an ITensor network on a graph specified by the inds network s. Bonddim is given by linkspace and entries are randomized. The random distribution is based on the input argument distribution.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.random_tensornetwork-Tuple{Random.AbstractRNG, Type, ITensorNetworks.IndsNetwork}","page":"Reference","title":"ITensorNetworks.random_tensornetwork","text":"Build an ITensor network on a graph specified by the inds network s. Bonddim is given by linkspace and entries are randomised (normal distribution, mean 0 std 1)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.scale!-Tuple{Function, ITensorNetworks.AbstractITensorNetwork}","page":"Reference","title":"ITensorNetworks.scale!","text":"Scale each tensor of the network via a function vertex -> Number\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.scale!-Tuple{ITensorNetworks.AbstractITensorNetwork, Dictionaries.Dictionary}","page":"Reference","title":"ITensorNetworks.scale!","text":"Scale each tensor of the network by a scale factor for each vertex in the keys of the dictionary\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.ttn-Tuple{ITensors.LazyApply.Applied{typeof(sum), Tuple{Array{ITensors.LazyApply.Applied{typeof(*), Tuple{C, ITensors.LazyApply.Prod{ITensors.Ops.Op}}, @NamedTuple{}}, 1}}, @NamedTuple{}} where C, ITensorNetworks.IndsNetwork}","page":"Reference","title":"ITensorNetworks.ttn","text":"ttn(os::OpSum, sites::IndsNetwork{<:Index}; kwargs...)\nttn(eltype::Type{<:Number}, os::OpSum, sites::IndsNetwork{<:Index}; kwargs...)\n\nConvert an OpSum object os to a TreeTensorNetwork, with indices given by sites.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.ttn_svd-Tuple{ITensors.LazyApply.Applied{typeof(sum), Tuple{Array{ITensors.LazyApply.Applied{typeof(*), Tuple{C, ITensors.LazyApply.Prod{ITensors.Ops.Op}}, @NamedTuple{}}, 1}}, @NamedTuple{}} where C, ITensorNetworks.IndsNetwork, Any}","page":"Reference","title":"ITensorNetworks.ttn_svd","text":"ttn_svd(os::OpSum, sites::IndsNetwork, root_vertex, kwargs...)\n\nConstruct a TreeTensorNetwork from a symbolic OpSum representation of a Hamiltonian, compressing shared interaction channels.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.update-Tuple{NDTensors.BackendSelection.Algorithm{:bp}, ITensorNetworks.AbstractBeliefPropagationCache}","page":"Reference","title":"ITensorNetworks.update","text":"More generic interface for update, with default params\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.update_factors-Tuple{ITensorNetworks.AbstractBeliefPropagationCache, Any}","page":"Reference","title":"ITensorNetworks.update_factors","text":"Update the tensornetwork inside the cache out-of-place\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.update_iteration-Tuple{NDTensors.BackendSelection.Algorithm{:bp}, ITensorNetworks.AbstractBeliefPropagationCache, Vector{<:Vector{<:NamedGraphs.PartitionedGraphs.QuotientEdge}}}","page":"Reference","title":"ITensorNetworks.update_iteration","text":"Do parallel updates between groups of edges of all message tensors Currently we send the full message tensor data struct to update for each edge_group. But really we only need the mts relevant to that group.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.update_iteration-Tuple{NDTensors.BackendSelection.Algorithm{:bp}, ITensorNetworks.AbstractBeliefPropagationCache, Vector}","page":"Reference","title":"ITensorNetworks.update_iteration","text":"Do a sequential update of the message tensors on edges\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.vidal_gauge_isometry-Tuple{ITensorNetworks.VidalITensorNetwork, Any}","page":"Reference","title":"ITensorNetworks.vidal_gauge_isometry","text":"Function to construct the 'isometry' of a state in the Vidal Gauge on the given edge\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.vidalitensornetwork_preserve_cache-Tuple{ITensorNetworks.ITensorNetwork}","page":"Reference","title":"ITensorNetworks.vidalitensornetwork_preserve_cache","text":"Use an ITensorNetwork ψ, its bond tensors and belief propagation cache to put ψ into the vidal gauge, return the bond tensors and updated_ψ.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensors.apply-Tuple{Union{ITensors.ITensor, NamedGraphs.NamedEdge}, ITensorNetworks.VidalITensorNetwork}","page":"Reference","title":"ITensors.apply","text":"Apply() function for an ITN in the Vidal Gauge. Hence the bond tensors are required. Gate does not necessarily need to be passed. Can supply an edge to do an identity update instead. Uses Simple Update procedure assuming gate is two-site\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.ModelNetworks.ising_network-Tuple{Type, ITensorNetworks.IndsNetwork, Number}","page":"Reference","title":"ITensorNetworks.ModelNetworks.ising_network","text":"BUILD Z OF CLASSICAL ISING MODEL ON A GIVEN GRAPH AT INVERSE TEMP BETA H = -\\sum{(v,v') \\in edges}\\sigma^{z}{v}\\sigma^{z}_{v'} OPTIONAL ARGUMENT: h: EXTERNAL MAGNETIC FIELD szverts: A LIST OF VERTICES OVER WHICH TO APPLY A SZ. THE RESULTANT NETWORK CAN THEN BE CONTRACTED AND DIVIDED BY THE ACTUAL PARTITION FUNCTION TO GET THAT OBSERVABLE INDSNETWORK IS ASSUMED TO BE BUILT FROM A GRAPH (NO SITE INDS) AND OF LINK SPACE 2\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.ModelNetworks.ising_network_state-Tuple{Type, ITensorNetworks.IndsNetwork, Number}","page":"Reference","title":"ITensorNetworks.ModelNetworks.ising_network_state","text":"Build the wavefunction whose norm is equal to Z of the classical ising model s needs to have site indices in this case!\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.ModelHamiltonians.heisenberg-Tuple{Graphs.AbstractGraph}","page":"Reference","title":"ITensorNetworks.ModelHamiltonians.heisenberg","text":"Random field J1-J2 Heisenberg model on a general graph\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.ModelHamiltonians.heisenberg-Tuple{Integer}","page":"Reference","title":"ITensorNetworks.ModelHamiltonians.heisenberg","text":"Random field J1-J2 Heisenberg model on a chain of length N\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.ModelHamiltonians.hubbard-Tuple{Graphs.AbstractGraph}","page":"Reference","title":"ITensorNetworks.ModelHamiltonians.hubbard","text":"t-t' Hubbard Model g,i,v\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.ModelHamiltonians.ising-Tuple{Graphs.AbstractGraph}","page":"Reference","title":"ITensorNetworks.ModelHamiltonians.ising","text":"Next-to-nearest-neighbor Ising model (ZZX) on a general graph\n\n\n\n\n\n","category":"method"},{"location":"reference/#ITensorNetworks.ModelHamiltonians.ising-Tuple{Integer}","page":"Reference","title":"ITensorNetworks.ModelHamiltonians.ising","text":"Next-to-nearest-neighbor Ising model (ZZX) on a chain of length N\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"[!WARNING] This is a pre-release software. There are no guarantees that functionality won't break from version to version, though we will try our best to indicate breaking changes following semantic versioning (semver) by bumping the minor version of the package. We are biasing heavily towards \"moving fast and breaking things\" during this stage of development, which will allow us to more quickly develop the package and bring it to a point where we have enough features and are happy enough with the external interface to officially release it for general public use.In short, use this package with caution, and don't expect the interface to be stable or for us to clearly announce parts of the code we are changing.","category":"section"},{"location":"#ITensorNetworks.jl","page":"Home","title":"ITensorNetworks.jl","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style) (Image: Aqua)","category":"section"},{"location":"#Support","page":"Home","title":"Support","text":"<img class=\"display-light-only\" src=\"assets/CCQ.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\"/>\n<img class=\"display-dark-only\" src=\"assets/CCQ-dark.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\"/>\n\nITensorNetworks.jl is supported by the Flatiron Institute, a division of the Simons Foundation.","category":"section"},{"location":"#Installation-instructions","page":"Home","title":"Installation instructions","text":"This package can be added as usual through the package manager:\n\njulia> using Pkg: Pkg\n\njulia> Pkg.add(\"ITensorNetworks\")","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"using ITensorNetworks: ITensorNetworks\n\nExamples go here.\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
